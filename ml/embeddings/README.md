# Qdrant Vector Database Integration

**Wave 2.2** - Fast similarity search for property embeddings

## Overview

This module integrates Qdrant vector database for efficient similarity search over property embeddings generated by the Portfolio Twin model.

### Why Qdrant?

- **Fast similarity search**: Find similar properties in milliseconds
- **Scalable**: Handles millions of vectors efficiently
- **Filtered search**: Combine vector similarity with metadata filters
- **Real-time updates**: Incremental indexing as new properties arrive
- **Multi-tenant**: Tenant-scoped filtering built-in

### Use Cases

1. **Look-Alike Properties**: "Find properties similar to this one"
2. **Portfolio Diversification**: "Show me properties different from my portfolio"
3. **Comp Analysis**: "What are the most similar sold properties?"
4. **User Recommendations**: "Properties matching this user's preferences"

## Architecture

```
┌──────────────────────────────────────────────────────────┐
│                    Property Flow                          │
└──────────────────────────────────────────────────────────┘

Database          Portfolio Twin        Qdrant
Properties   →   Generate Embeddings  →  Index Vectors

                                           ↓

                                    Similarity Search
                                           ↓

                                    API Endpoints
                                    /search/similar
                                    /search/look-alikes
                                    /search/recommend
```

## Components

### 1. QdrantVectorDB (`qdrant_client.py`)

Low-level client for Qdrant operations.

**Collections**:
- `property_embeddings`: Property vectors (16-dim)
- `user_embeddings`: User preference vectors (16-dim)

**Indexes**:
- `tenant_id`: Keyword index for multi-tenant filtering
- `property_type`: Keyword index (Single Family, Condo, etc.)
- `zipcode`: Keyword index for location filtering
- `listing_price`: Float index for price range filtering

**Key Methods**:
- `create_collections()`: Initialize Qdrant collections
- `index_property()`: Index single property
- `index_properties_batch()`: Batch indexing
- `search_similar_properties()`: Vector similarity search
- `find_look_alikes()`: Find properties similar to reference property
- `delete_property()`: Remove property from index

### 2. PropertyEmbeddingIndexer (`indexer.py`)

Syncs property embeddings from database to Qdrant.

**Workflow**:
1. Load properties from PostgreSQL
2. Extract PropertyFeatures
3. Generate embeddings with Portfolio Twin encoder
4. Batch index into Qdrant

**CLI Usage**:
```bash
python ml/embeddings/indexer.py \
  --tenant-id 00000000-0000-0000-0000-000000000001 \
  --model-path ml/serving/models/portfolio_twin.pt \
  --batch-size 100 \
  --recreate
```

### 3. SimilaritySearchService (`similarity_service.py`)

FastAPI service for similarity search.

**Endpoints**:
- `POST /search/similar`: Search by embedding vector
- `GET /search/look-alikes/{property_id}`: Find similar properties
- `POST /search/recommend`: User-specific recommendations

**Features**:
- Tenant-scoped filtering
- Metadata filtering (type, zipcode, price)
- Integration with Portfolio Twin for personalized results

### 4. Embedding Indexing DAG (`../dags/embedding_indexing.py`)

Airflow DAG for automated indexing.

**Schedule**: Daily at 3 AM

**Tasks**:
1. Check Qdrant health
2. Verify model exists
3. Count properties (DB vs Qdrant)
4. Index embeddings (full or incremental)
5. Verify indexing success
6. Test similarity search

## Setup

### Start Qdrant Server

**Option 1: Docker Compose**

```bash
docker-compose -f docker-compose.qdrant.yml up -d
```

**Option 2: Docker Manual**

```bash
docker run -p 6333:6333 -p 6334:6334 \
  -v $(pwd)/qdrant_storage:/qdrant/storage \
  qdrant/qdrant:latest
```

**Option 3: Local Install** (macOS)

```bash
brew install qdrant
qdrant
```

**Verify Running**:

```bash
curl http://localhost:6333/health
# Should return: {"title":"qdrant - vector search engine","version":"1.x.x"}
```

### Install Python Client

```bash
pip install qdrant-client
```

### Create Collections

```python
from ml.embeddings.qdrant_client import QdrantVectorDB

qdrant = QdrantVectorDB(host="localhost", port=6333)
qdrant.create_collections(embedding_dim=16, recreate=True)
```

## Usage

### 1. Index Properties

**Full Index** (first time):

```bash
python ml/embeddings/indexer.py \
  --tenant-id 00000000-0000-0000-0000-000000000001 \
  --model-path ml/serving/models/portfolio_twin.pt \
  --db-url postgresql://user:pass@localhost/realestate \
  --qdrant-host localhost \
  --qdrant-port 6333 \
  --batch-size 100 \
  --recreate
```

**Incremental Update**:

```bash
python ml/embeddings/indexer.py \
  --tenant-id 00000000-0000-0000-0000-000000000001 \
  --model-path ml/serving/models/portfolio_twin.pt
```

**Via Airflow**:

```bash
airflow dags trigger embedding_indexing \
  --conf '{
    "tenant_id": "00000000-0000-0000-0000-000000000001",
    "db_url": "postgresql://user:pass@localhost/realestate",
    "model_path": "ml/serving/models/portfolio_twin.pt",
    "qdrant_host": "localhost",
    "qdrant_port": 6333,
    "batch_size": 100
  }'
```

### 2. Similarity Search

**Start Service**:

```bash
python ml/embeddings/similarity_service.py
# Runs on http://localhost:8002
```

**Find Look-Alike Properties**:

```bash
curl -X GET "http://localhost:8002/search/look-alikes/property-123?tenant_id=00000000-0000-0000-0000-000000000001&top_k=10"
```

Response:
```json
{
  "results": [
    {
      "property_id": "property-456",
      "similarity_score": 0.92,
      "listing_price": 550000,
      "bedrooms": 3,
      "bathrooms": 2.0,
      "property_type": "Single Family",
      "zipcode": "94102"
    },
    ...
  ],
  "total_results": 10
}
```

**Search with Filters**:

```bash
curl -X GET "http://localhost:8002/search/look-alikes/property-123?tenant_id=00000000-0000-0000-0000-000000000001&top_k=10&property_type=Single%20Family&zipcode=94102"
```

**Custom Embedding Search**:

```bash
curl -X POST http://localhost:8002/search/similar \
  -H "Content-Type: application/json" \
  -d '{
    "query_embedding": [0.1, 0.2, ..., 0.16],
    "top_k": 10,
    "filters": {
      "property_type": "Condo",
      "zipcode": "94102"
    }
  }?tenant_id=00000000-0000-0000-0000-000000000001'
```

### 3. Python API

```python
from ml.embeddings.qdrant_client import QdrantVectorDB, PropertyEmbedding
from ml.embeddings.indexer import PropertyEmbeddingIndexer
import numpy as np

# Connect to Qdrant
qdrant = QdrantVectorDB(host="localhost", port=6333)

# Find similar properties
similar = qdrant.find_look_alikes(
    property_id="property-123",
    tenant_id="00000000-0000-0000-0000-000000000001",
    top_k=10,
    filters={"property_type": "Single Family"}
)

for prop in similar:
    print(f"{prop.property_id}: {prop.similarity_score:.3f}")

# Custom search
query_embedding = np.random.randn(16)  # Your embedding
results = qdrant.search_similar_properties(
    query_embedding=query_embedding,
    tenant_id="00000000-0000-0000-0000-000000000001",
    top_k=10
)

# Index a single property
indexer = PropertyEmbeddingIndexer(
    model_path="ml/serving/models/portfolio_twin.pt",
    qdrant_host="localhost",
    qdrant_port=6333
)

indexer.index_property(
    db_session=db,
    property_id="property-456",
    tenant_id="00000000-0000-0000-0000-000000000001"
)
```

## Features

### Multi-Tenant Filtering

All searches automatically filter by `tenant_id`:

```python
# Tenant A can only see their properties
results = qdrant.search_similar_properties(
    query_embedding=embedding,
    tenant_id="tenant-a-uuid",
    top_k=10
)
# Returns only tenant A's properties
```

### Metadata Filtering

Combine vector similarity with structured filters:

```python
# Find similar 3-bedroom condos in SF
filters = {
    "property_type": "Condo",
    "zipcode": "94102"
}

similar = qdrant.search_similar_properties(
    query_embedding=embedding,
    tenant_id=tenant_id,
    top_k=10,
    filters=filters
)
```

### Batch Operations

Efficient batch indexing:

```python
# Index 1000 properties in batches of 100
indexer.index_properties_batch(
    property_embeddings=embeddings_list,
    batch_size=100
)
```

### Incremental Updates

Update individual properties without full reindex:

```python
# Property updated in database
indexer.index_property(
    db_session=db,
    property_id="updated-property-id",
    tenant_id=tenant_id
)
```

## Data Model

### PropertyEmbedding

```python
@dataclass
class PropertyEmbedding:
    property_id: str              # Unique property ID
    embedding: np.ndarray         # 16-dim embedding vector
    tenant_id: str                # Tenant UUID
    listing_price: Optional[float]
    bedrooms: Optional[int]
    bathrooms: Optional[float]
    property_type: Optional[str]  # Single Family, Condo, etc.
    zipcode: Optional[str]
    confidence: float             # Data confidence [0-1]
```

### Qdrant Point Structure

```json
{
  "id": "property-123",
  "vector": [0.12, -0.34, ..., 0.89],  // 16 dimensions
  "payload": {
    "property_id": "property-123",
    "tenant_id": "00000000-0000-0000-0000-000000000001",
    "listing_price": 500000,
    "bedrooms": 3,
    "bathrooms": 2.0,
    "property_type": "Single Family",
    "zipcode": "94102",
    "confidence": 0.85
  }
}
```

## Performance

### Benchmarks

**Search Latency** (1M properties):
- Top-10 search: ~5-10ms
- With filters: ~10-20ms
- gRPC (faster): ~3-8ms

**Indexing Throughput**:
- Single property: ~2ms
- Batch (100 properties): ~50ms
- Full index (10K properties): ~2 minutes

**Memory Usage**:
- 16-dim vectors: ~64 bytes per property
- 1M properties: ~64 MB vectors + ~100 MB metadata

### Optimization Tips

1. **Use gRPC**: Set `prefer_grpc=True` for 2-3x faster operations
2. **Batch operations**: Index in batches of 100-1000
3. **Async indexing**: Run indexing DAG during off-peak hours
4. **HNSW tuning**: Adjust `m` and `ef_construct` for speed/quality tradeoff
5. **Quantization**: Use scalar quantization to reduce memory (future)

## Monitoring

### Collection Stats

```python
stats = qdrant.get_collection_info("property_embeddings")

print(f"Total vectors: {stats['vectors_count']}")
print(f"Indexed vectors: {stats['indexed_vectors_count']}")
print(f"Status: {stats['status']}")
```

### Health Check

```bash
curl http://localhost:6333/health
curl http://localhost:8002/health  # Similarity service
```

### Metrics to Track

- **Index freshness**: Time since last full reindex
- **Coverage**: Properties in Qdrant / Properties in database
- **Search latency**: P50, P95, P99 response times
- **Query throughput**: Searches per second
- **Error rate**: Failed searches / Total searches

## Troubleshooting

### Qdrant Connection Failed

**Problem**: `ConnectionRefusedError: [Errno 61] Connection refused`

**Solution**:
```bash
# Check if Qdrant is running
docker ps | grep qdrant

# Start Qdrant
docker-compose -f docker-compose.qdrant.yml up -d

# Check logs
docker logs realestate-qdrant
```

### Collection Not Found

**Problem**: `Collection 'property_embeddings' not found`

**Solution**:
```python
from ml.embeddings.qdrant_client import QdrantVectorDB

qdrant = QdrantVectorDB()
qdrant.create_collections(embedding_dim=16, recreate=False)
```

### Indexing Too Slow

**Problem**: Indexing taking too long

**Solution**:
1. Increase batch size: `--batch-size 500`
2. Use GPU for embeddings: `--device cuda`
3. Use gRPC: `prefer_grpc=True`
4. Disable unnecessary logging

### Search Returns No Results

**Problem**: Similarity search returns empty results

**Solution**:
1. Check if properties indexed: `qdrant.get_collection_info("property_embeddings")`
2. Verify tenant_id filter matches
3. Check if query embedding is normalized
4. Reduce `top_k` and remove filters to test

### Out of Memory

**Problem**: Qdrant using too much memory

**Solution**:
1. Enable quantization (reduces memory by 4x)
2. Reduce `m` parameter in HNSW config
3. Use disk storage instead of in-memory
4. Shard collection across multiple Qdrant instances

## Advanced Features

### Custom Distance Metrics

Qdrant supports multiple distance metrics:

```python
from qdrant_client.models import Distance, VectorParams

# Cosine similarity (default)
VectorParams(size=16, distance=Distance.COSINE)

# Euclidean distance
VectorParams(size=16, distance=Distance.EUCLID)

# Dot product
VectorParams(size=16, distance=Distance.DOT)
```

### Hybrid Search

Combine semantic and keyword search:

```python
# Coming in Wave 2.3
# Search by embedding + full-text on description
```

### Quantization

Reduce memory usage:

```python
# Enable scalar quantization
from qdrant_client.models import ScalarQuantization

qdrant.update_collection(
    collection_name="property_embeddings",
    quantization_config=ScalarQuantization(
        scalar=ScalarQuantizationConfig(
            type=ScalarType.INT8,
            quantile=0.99
        )
    )
)
```

## Next Steps

### Wave 2.3: Enhanced Recommendations

- User embedding persistence
- Hybrid search (vector + keyword)
- Multi-vector properties (image + text)
- Time-decay for recency

### Wave 2.4: UI Integration

- "Similar Properties" widget in property drawer
- Visual embedding space explorer
- Comp analysis tool with Qdrant backend
- Real-time recommendations as user browses

## References

- **Qdrant Docs**: https://qdrant.tech/documentation/
- **Python Client**: https://github.com/qdrant/qdrant-client
- **HNSW Algorithm**: https://arxiv.org/abs/1603.09320
- **Vector Search Guide**: https://www.pinecone.io/learn/vector-database/

---

**Wave 2.2 Complete** - Qdrant vector database for fast similarity search ✅
